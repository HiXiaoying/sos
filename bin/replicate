#!/usr/bin/perl

=head1 NAME

replicate - The SOS replication utility

=cut

=head1 SYNOPSIS

  replicate [options]

  General Options:

   --deamon      Specify that we should run constantly.
   --min-copies  Specify the minimum copies of data required.
   --verbose     Show more explicitly what is going on.

  Help Options:

   --help        Show brief help instructions.
   --manual      Show the manual.

=cut

=head1 OVERVIEW

This utility is designed to synchronize the contents of an arbitrary
number of blob-servers.  It does this by contacting each known blob-server
and retrieving a list of the objects stored upon it.

For each object we then look to see how many times it is replicated,
if a particular object is not stored sufficient times it is uploaded
to other random blob-servers until the threshold is reached.

The list of servers to contact is read from either:

=over 8

=item /etc/sos.conf

=item ~/.sos.conf

=back

=cut

=head1 NOTES

It is not necessary for the blob-servers to communicate with each other,
providing the host running the replicate-script can communicate with
each of them.

=cut

=head1 LICENSE

This module is free software; you can redistribute it and/or modify it
under the terms of either:

a) the GNU General Public License as published by the Free Software
Foundation; either version 2, or (at your option) any later version,
or

b) the Perl "Artistic License".

=cut

=head1 AUTHOR

Steve Kemp <steve@steve.org.uk>

=cut


use strict;
use warnings;

use Encode qw(encode);
use Getopt::Long;
use JSON;
use LWP::UserAgent;
use Pod::Usage;


package SOS::Servers;



sub new
{
    my ($proto) = (@_);
    my $class = ref($proto) || $proto;
    my $self = {};

    # servers
    $self->{ 'servers' } = undef;

    bless( $self, $class );

    # Load our data.
    $self->_readFiles();
    return $self;
}


=begin doc

Read the known configuration files we understand.

Called when this object is instantiated.

=end doc

=cut

sub _readFiles
{
    my ($self) = (@_);

    $self->_readFile("/etc/sos.conf");
    $self->_readFile( $ENV{ 'HOME' } . "/.sos.conf" );
}


=begin doc

Read the known configuration files we understand.

=end doc

=cut

sub _readFile
{
    my ( $self, $file ) = (@_);

    return unless ( -e $file );

    my @data;

    open( my $handle, "<", $file ) or
      die "Failed to open $file - $!";
    while ( my $line = <$handle> )
    {
        chomp($line);
        next if ( $line =~ /^#/ );

        push( @data, $line );
    }
    close($handle);

    #
    #  OK this is either a literal list of servers, or
    # a list of ini-like sections.
    #
    my $is_ini = 0;

    foreach my $line (@data)
    {
        $is_ini = 1 if ( $line =~ /^\[(.*)\]$/ );
    }

    #
    #  Parse literal list, simple
    #
    if ( $is_ini == 0 )
    {
        foreach my $line (@data)
        {
            if ( $line =~ /^http/i )
            {
                $self->{ 'servers' }{ "default" }{ $line } = 1;
            }
        }
    }
    else
    {
        # Parse INI-file
        my $section = "";

        foreach my $line (@data)
        {
            # section
            if ( $line =~ /^\[(.*)\]$/ )
            {
                $section = $1;
            }
            if ( ( $line =~ /^-:(.*)$/ ) && $section )
            {
                # hostname
                my $uri = $1;
                $uri =~ s/^\s+//;
                $uri =~ s/\s+$//;

                $self->{ 'servers' }{ $section }{ $uri } = 1;
            }
        }
    }
}

=begin doc

Return the list of servers we've discovered via our configuration
file parsing.

=end doc

=cut

sub servers
{
    my ($self) = (@_);

    return ( %{ $self->{ 'servers' } } );
}




package main;


#
#  Default options: Don't be verbose and require two copies of each object.
#
my %CONFIG;
$CONFIG{ 'copies' }  = 2;
$CONFIG{ 'verbose' } = 0;


=begin doc

Given a list of servers make sure that each one has the same contents
as the rest in the list.

=end doc

=cut

sub replicate_group
{
    my (@nodes) = (@_);

    #
    # Get the list of objects on each server in the group.
    #
    my %objects = populateObjects(@nodes);

    #
    # OK so we have a list of servers, and the objects each contains.
    #
    # We want to make sure that every object is stored within every
    # other node in that set.
    #
    foreach my $server ( sort keys %objects )
    {
        #
        # So we've got a server we want to replicate
        # make sure it is alive.
        #
        if ( is_alive($server) == 0 )
        {
            print "SERVER OFFLINE - Skipping - $server\n";
            next;
        }

        #
        # Look for all other servers in the group
        #
        foreach my $mirror ( sort keys %objects )
        {
            next if ( $mirror eq $server );

            $CONFIG{ 'verbose' } && print "Mirroring from $server -> $mirror\n";

            if ( is_alive($mirror) == 0 )
            {
                print "SERVER OFFLINE - Cannot replicate $server -> $mirror\n";
                next;
            }

            #
            #  The objects we wish to replicate.
            #
            my @ids = keys %{ $objects{ $server } };

            #
            #  SHow them
            #
            foreach my $id (@ids)
            {
                $CONFIG{ 'verbose' } && print "\t$id";

                if ( $objects{ $mirror }{ $id } )
                {
                    $CONFIG{ 'verbose' } && print " - present\n";
                }
                else
                {
                    $CONFIG{ 'verbose' } && print " - ";
                    replicate_object( $id, $server, $mirror );
                }
            }
        }
    }

}




#
# Replicate the given file
#
sub replicate_object
{
    my ( $id, $src, $dst ) = (@_);

    #  OK we've now got to download the content
    #
    my $lwp = LWP::UserAgent->new;
    my $uri = $src . "/blob/$id";
    my $res = $lwp->get($uri);

    if ( $res->is_success() )
    {
        #
        #  We have the data now, ensure it is UTF-8.
        #
        my $data = $res->decoded_content();
        my $body = encode( 'UTF-8', $data );

        #
        #  Now upload to new location
        #
        my $req = HTTP::Request->new( 'POST', $dst . "/blob/$id" );
        $req->content($body);

        my $res = $lwp->request($req);
        if ( $res->is_success() )
        {
            $CONFIG{ 'verbose' } && print "replicated.\n";
        }
        else
        {
            print "FAILED to replicate" . $res->status_line() . "\n";
        }
    }
    else
    {
        die "Failed to download $uri to replicate to $dst";
    }
}


#
# Populate a hash of each known object on each server.
#
sub populateObjects
{
    my (@nodes) = (@_);

    my %ret;

    foreach my $server ( sort(@nodes) )
    {
        #
        #  Ensure this server has an empty hash against it.
        #
        my %x;
        $ret{ $server } = \%x;

        $CONFIG{ 'verbose' } &&
          print "Downloading contents of blob-server $server\n";

        if ( is_alive($server) == 0 )
        {
            print "\tServer offline - $server\n";
            next;
        }

        my $lwp = LWP::UserAgent->new;

        my $uri = $server . "/blob";
        my $res = $lwp->get($uri);

        if ( $res->is_success() )
        {
            my $ids = decode_json( $res->decoded_content() );

            foreach my $id (@$ids)
            {
                $ret{ $server }{ $id } = 1;
            }
        }
        else
        {
            die "Failed to download contents from server $server";
        }
    }
    $CONFIG{ 'verbose' } &&
      print "\n";

    return (%ret);

}


=begin doc

Is the given server alive?  (Caches result).

=end doc

=cut

my %alive;

sub is_alive
{
    my ($server) = (@_);

    return ( $alive{ $server } ) if ( defined $alive{ $server } );


    my $ua = LWP::UserAgent->new;
    $ua->timeout(10);
    $ua->env_proxy;

    my $response = $ua->get( $server . '/alive' );
    my $code     = $response->code();
    my $body     = $response->decoded_content();

    if ( $body && $body =~ /^alive$/i )
    {
        $alive{ $server } = 1;
    }
    else
    {
        $alive{ $server } = 0;
    }

    return ( $alive{ $server } );
}



#
#  Parse options from the command-line.
#
exit
  if (
    !GetOptions(

        # Help options
        "help",         \$CONFIG{ 'help' },
        "manual",       \$CONFIG{ 'manual' },
        "verbose",      \$CONFIG{ 'verbose' },
        "min-copies=i", \$CONFIG{ 'copies' },
        "daemon=i",     \$CONFIG{ 'daemon' },
    ) );


pod2usage(1) if ( $CONFIG{ 'help' } );
pod2usage( -verbose => 2 ) if ( $CONFIG{ 'manual' } );


#
#  If we've been given a --daemon flag then we'll repeat
# the sync, otherwise we'll just run it once.
#
do
{

    #
    #  Parse the configuration file(s) so we get a list of servers.
    #
    my $obj = SOS::Servers->new();
    my %srv = $obj->servers();

    #
    # If we have no servers then we must abort.
    #
    if ( !scalar( keys %srv ) )
    {
        print <<EOF;
No servers were found in the configuration file(s).  Aborting.
EOF
        exit(1);
    }


    #
    #  For each group we need to replicate the contents.
    #
    foreach my $group ( sort keys %srv )
    {
        $CONFIG{ 'verbose' } && print "Replicating group: $group\n";

        my @nodes = sort keys( %{ $srv{ $group } } );

        replicate_group(@nodes);
    }

    # sleep?
    sleep( $CONFIG{ 'daemon' } ) if ( $CONFIG{ 'daemon' } );

} while ( $CONFIG{ 'daemon' } );


#
#  All done.
#
exit(0);
